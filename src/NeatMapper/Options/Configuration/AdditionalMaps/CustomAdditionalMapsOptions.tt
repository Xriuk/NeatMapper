<#@ template hostspecific="true" language="C#" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#
	string[] additionalMapsOptions = new []{
		"New", "Merge",
		"Match", "HierarchyMatch",
		"AsyncNew", "AsyncMerge",
		"Projection"
	};
	string[] canDelegate = new []{
		"MapNew", "MapMerge",
		"Match", "MatchHierarchy",
		"MapAsyncNew", "MapAsyncMerge",
		"Project"
	};

	for(var i = 0; i < additionalMapsOptions.Length; i++){
		var name = additionalMapsOptions[i];
		var canDelegName = canDelegate[i];
#>
// This code was generated by a tool (CustomAdditionalMapsOptions.tt).
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

using System;
using System.Collections.Generic;

namespace NeatMapper {
	/// <summary>
	/// Options which allow to specify additional user-defined mappings (and optionally checks for them),
	/// to be added to maps found in types in <see cref="CustomMapsOptions"/>.
	/// </summary>
	public sealed class Custom<#= name #>AdditionalMapsOptions {
		/// <summary>
		/// Creates a new instance of <see cref="Custom<#= name #>AdditionalMapsOptions"/>.
		/// </summary>
		public Custom<#= name #>AdditionalMapsOptions() {
			_maps = [];
		}
		/// <summary>
		/// Creates a new instance of <see cref="Custom<#= name #>AdditionalMapsOptions"/>
		/// by copying options from another instance.
		/// </summary>
		/// <param name="options">Options to copy from.</param>
		public Custom<#= name #>AdditionalMapsOptions(Custom<#= name #>AdditionalMapsOptions options) {
			if (options == null)
				throw new ArgumentNullException(nameof(options));

			_maps = new Dictionary<(Type From, Type To), CustomAdditionalMap>(options._maps);
		}

		internal readonly Dictionary<(Type From, Type To), CustomAdditionalMap> _maps = [];
		internal readonly Dictionary<(Type From, Type To), CustomAdditionalMap> _canMaps = [];


		/// <summary>
		/// Adds a custom map, this will later throw if another map for the same types was defined
		/// in one of the types in <see cref="CustomMapsOptions"/>.
		/// </summary>
		/// <param name="mapDelegate">Mapping method to use.</param>
		public void AddMap<TSource, TDestination>(<#= name #>MapDelegate<TSource, TDestination> mapDelegate) {
			AddMapInternal(mapDelegate, null, true);
		}
		/// <summary>
		/// Adds a custom map, this will later throw if another map for the same types was defined
		/// in one of the types in <see cref="CustomMapsOptions"/>.
		/// </summary>
		/// <param name="mapDelegate">Mapping method to use.</param>
		/// <param name="canMapDelegate">Optional check method which will be called before the mapping method.</param>
		public void AddMap<TSource, TDestination>(<#= name #>MapDelegate<TSource, TDestination> mapDelegate, Can<#= canDelegName #>Delegate<TSource, TDestination>? canMapDelegate) {
			AddMapInternal(mapDelegate, canMapDelegate, true);
		}

		/// <summary>
		/// Adds a custom map, this won't throw if another map for the same types was defined
		/// in one of the types in <see cref="CustomMapsOptions"/>, the map will be ignored.
		/// </summary>
		/// <param name="mapDelegate">Mapping method to use.</param>
		public void TryAddMap<TSource, TDestination>(<#= name #>MapDelegate<TSource, TDestination> mapDelegate) {
			AddMapInternal(mapDelegate, null, false);
		}
		/// <summary>
		/// Adds a custom map, this won't throw if another map for the same types was defined
		/// in one of the types in <see cref="CustomMapsOptions"/>, the map will be ignored.
		/// </summary>
		/// <param name="mapDelegate">Mapping method to use.</param>
		/// <param name="canMapDelegate">Optional check method which will be called before the mapping method.</param>
		public void TryAddMap<TSource, TDestination>(<#= name #>MapDelegate<TSource, TDestination> mapDelegate, Can<#= canDelegName #>Delegate<TSource, TDestination>? canMapDelegate) {
			AddMapInternal(mapDelegate, canMapDelegate, false);
		}


		private void AddMapInternal<TSource, TDestination>(<#= name #>MapDelegate<TSource, TDestination> mapDelegate, Can<#= canDelegName #>Delegate<TSource, TDestination>? canMapDelegate, bool throwOnDuplicate) {
			if (mapDelegate == null)
				throw new ArgumentNullException(nameof(mapDelegate));

			if (_maps.ContainsKey((typeof(TSource), typeof(TDestination))) || (canMapDelegate != null && _canMaps.ContainsKey((typeof(TSource), typeof(TDestination)))))
				throw new ArgumentException($"Duplicate map for types {typeof(TSource).FullName ?? typeof(TSource).Name} -> {typeof(TDestination).FullName ?? typeof(TDestination).Name}");

			var map = new CustomAdditionalMap {
				From = typeof(TSource),
				To = typeof(TDestination),
				ThrowOnDuplicate = throwOnDuplicate
			};
			if ((mapDelegate.Method.GetType().FullName?.StartsWith("System.Reflection.Emit.DynamicMethod") == true)) {
				<#= name #>MapDelegate<TSource, TDestination> method = mapDelegate.Invoke;
				map.Method = method.Method;
				map.Instance = mapDelegate;
			}
			else
				map.Method = mapDelegate.Method;
			_maps.Add((typeof(TSource), typeof(TDestination)), map);

			if(canMapDelegate != null){
				map = new CustomAdditionalMap {
					From = typeof(TSource),
					To = typeof(TDestination),
					ThrowOnDuplicate = throwOnDuplicate
				};
				if ((canMapDelegate.Method.GetType().FullName?.StartsWith("System.Reflection.Emit.DynamicMethod") == true)) {
					Can<#= canDelegName #>Delegate<TSource, TDestination> method = canMapDelegate.Invoke;
					map.Method = method.Method;
					map.Instance = canMapDelegate;
				}
				else
					map.Method = canMapDelegate.Method;
				_canMaps.Add((typeof(TSource), typeof(TDestination)), map);
			}
		}
	}
}
<#
	SaveOutput($"Custom{name}AdditionalMapsOptions.cs");
}
#>

<#+
void SaveOutput(string outputFileName) {
  string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
  string outputFilePath = Path.Combine(templateDirectory, outputFileName);
  File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString()); 
  this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
}
#>