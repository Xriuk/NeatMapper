// This code was generated by a tool (MethodCache.tt).
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

using System;
using System.Collections.Concurrent;
using System.Reflection;

namespace NeatMapper.EntityFrameworkCore {
	internal sealed class MethodCacheFunc<TKey, TReturn> 
#if NETCOREAPP3_1 || NET5_0_OR_GREATER
		where TKey : notnull
#endif
		{
		private readonly ConcurrentDictionary<TKey, Func<TReturn>> _cache =
			new ConcurrentDictionary<TKey, Func<TReturn>>();

		private readonly Func<TKey, MethodInfo> _methodSelector;
		private readonly Func<TKey> _keySelector;
		private readonly string[] _parameterNames;


		public MethodCacheFunc(Func<TKey> keySelector, Func<TKey, MethodInfo> methodSelector, params string[] parameterNames) {
			_methodSelector = methodSelector;
			_keySelector = keySelector;
			_parameterNames = parameterNames;
		}

		public TReturn Invoke() {
			return _cache.GetOrAdd(_keySelector.Invoke(), k =>
				NeatMapper.TypeUtils.MethodToDelegate<Func<TReturn>>(_methodSelector.Invoke(k), null, _parameterNames))
					.Invoke();
		}
	}

	internal sealed class MethodCacheFunc<TKey, TArg0, TReturn> 
#if NETCOREAPP3_1 || NET5_0_OR_GREATER
		where TKey : notnull
#endif
		{
		private readonly ConcurrentDictionary<TKey, Func<TArg0, TReturn>> _cache =
			new ConcurrentDictionary<TKey, Func<TArg0, TReturn>>();

		private readonly Func<TKey, MethodInfo> _methodSelector;
		private readonly Func<TArg0, TKey> _keySelector;
		private readonly string[] _parameterNames;


		public MethodCacheFunc(Func<TArg0, TKey> keySelector, Func<TKey, MethodInfo> methodSelector, params string[] parameterNames) {
			_methodSelector = methodSelector;
			_keySelector = keySelector;
			_parameterNames = parameterNames;
		}

		public TReturn Invoke(TArg0 arg0) {
			return _cache.GetOrAdd(_keySelector.Invoke(arg0), k =>
				NeatMapper.TypeUtils.MethodToDelegate<Func<TArg0, TReturn>>(_methodSelector.Invoke(k), null, _parameterNames))
					.Invoke(arg0);
		}
	}

	internal sealed class MethodCacheFunc<TKey, TArg0, TArg1, TReturn> 
#if NETCOREAPP3_1 || NET5_0_OR_GREATER
		where TKey : notnull
#endif
		{
		private readonly ConcurrentDictionary<TKey, Func<TArg0, TArg1, TReturn>> _cache =
			new ConcurrentDictionary<TKey, Func<TArg0, TArg1, TReturn>>();

		private readonly Func<TKey, MethodInfo> _methodSelector;
		private readonly Func<TArg0, TArg1, TKey> _keySelector;
		private readonly string[] _parameterNames;


		public MethodCacheFunc(Func<TArg0, TArg1, TKey> keySelector, Func<TKey, MethodInfo> methodSelector, params string[] parameterNames) {
			_methodSelector = methodSelector;
			_keySelector = keySelector;
			_parameterNames = parameterNames;
		}

		public TReturn Invoke(TArg0 arg0, TArg1 arg1) {
			return _cache.GetOrAdd(_keySelector.Invoke(arg0, arg1), k =>
				NeatMapper.TypeUtils.MethodToDelegate<Func<TArg0, TArg1, TReturn>>(_methodSelector.Invoke(k), null, _parameterNames))
					.Invoke(arg0, arg1);
		}
	}

}